@page "/"
@using System.Text
@using System.IO
@using Microsoft.AspNetCore.Hosting
@using SharpAESCryptWASMCore.Shared

@inject IJSRuntime JSRuntime
@inject NotificationService NotificationService

<PageTitle>Index</PageTitle>

<h1>Sharp AES Crypt WASM</h1>

<div class="row">
    <div class="col-md-4 p-3">
        <RadzenCard>
            <h4 class="mb-4">Select File</h4>
            <RadzenFileInput @bind-Value=@fileBase64 TValue="string" Class="w-100" Change=@(args => RadzenFileInputOnChange(args, "FileInput")) Error=@(args => RadzenFileInputOnError(args, "FileInput")) />
            <h6 class="mb-4">File Name: <b>@(fileName)</b></h6>
        </RadzenCard>
    </div>
    <div class="col-md-4 p-3">
        <RadzenCard>
            <h4 class="mb-4">Encryption selection</h4>
            <RadzenSelectBar @bind-Value=@fileEncrypted TValue="bool">
                <Items>
                    <RadzenSelectBarItem Text="Encrypted" Value="true" />
                    <RadzenSelectBarItem Text="Decrypted" Value="false" />
                </Items>
            </RadzenSelectBar>
        </RadzenCard>
    </div>
</div>
<div class="row">
    <div class="col-md-4 p-3">
        <RadzenCard>
            <h4 class="mb-4">Password</h4>
            <RadzenPassword Change=@(args => PasswordOnChange(args, "Password")) Class="w-100" />
        </RadzenCard>
    </div>
    <div class="col-md-4 p-3">
        <RadzenCard>
            <h4 class="mb-4">Download File</h4>
            <RadzenButton Click=@(args => DownloadFileFromStream()) Text="Download" ButtonStyle="ButtonStyle.Primary" />
        </RadzenCard>
    </div>
</div>

@code{
    private string? fileName { get{ return "NewTextDocumentCopy.txt"; }  }
    private long? fileSize { get; set; }
    private byte[]? fileByte { get; set; }
    private string? fileBase64 { get; set; }
    private string? secretKey { get; set; }
    private string? secretExtension { get { return ".aes"; }}
    private bool fileEncrypted { get; set; }
    private MemoryStream inputStream = new MemoryStream();
    private MemoryStream outputStream = new MemoryStream();

    private void ShowNotification(NotificationMessage message)
    {
        NotificationService.Notify(message);
    }

    private void RadzenFileInputOnError(UploadErrorEventArgs args, string name)
    {
        ShowNotification(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error Summary", Detail = args.Message, Duration = 4000 });
    }

    private void RadzenFileInputOnChange(string value, string name)
    {
        if (!String.IsNullOrEmpty(value))
        {
            string[] result = value.Split(",");
            fileBase64 = result[1];
        }
        else
        {
            fileBase64 = value;
        }

        this.StateHasChanged();
    }

    private void PasswordOnChange(string value, string name)
    {
        secretKey = value;
    }

    private async Task<Stream> GetFileStream()
    {
        if (fileEncrypted == true)
        {
            inputStream = new MemoryStream(Convert.FromBase64String(fileBase64));
            inputStream.Position = 0;

            SharpAESCrypt.Decrypt(secretKey, inputStream, outputStream);
            outputStream.Position = 0;
        }
        else
        {
            inputStream = new MemoryStream(Convert.FromBase64String(fileBase64));
            inputStream.Position = 0;

            SharpAESCrypt.Encrypt(secretKey, inputStream, outputStream);
            outputStream.Position = 0;
        }

        return outputStream;
    }

    private async Task DownloadFileFromStream()
    {
        if (!String.IsNullOrEmpty(fileName))
        {
            string getFileName = string.Empty;
            if(fileName == (fileName + secretExtension))
            {
                getFileName = fileName.Replace(secretExtension, string.Empty);
            }
            else
            {
                getFileName = fileName + secretExtension;
            }

            var fileStream = await GetFileStream();

            //using var streamRef = new DotNetStreamReference(stream: fileStream);

            await JSRuntime.InvokeVoidAsync("downloadFileFromStream", getFileName, fileStream);
        }
    }
}